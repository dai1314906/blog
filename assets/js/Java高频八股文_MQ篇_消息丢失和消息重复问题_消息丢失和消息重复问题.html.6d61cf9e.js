"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3854],{5089:(a,e,p)=>{p.r(e),p.d(e,{comp:()=>g,data:()=>c});var t=p(641);const i=p.p+"assets/img/1.f69d3383.png",n=p.p+"assets/img/2.9271f443.png",r=p.p+"assets/img/3.e1045d6a.png",o=p.p+"assets/img/4.3acf1a60.png",s={},g=(0,p(6262).A)(s,[["render",function(a,e){return(0,t.uX)(),(0,t.CE)("div",null,e[0]||(e[0]=[(0,t.Fv)('<h1 id="mq消息丢失与消息重复问题" tabindex="-1"><a class="header-anchor" href="#mq消息丢失与消息重复问题"><span>MQ消息丢失与消息重复问题</span></a></h1><h2 id="一、mq消息丢失问题" tabindex="-1"><a class="header-anchor" href="#一、mq消息丢失问题"><span>一、MQ消息丢失问题</span></a></h2><p>在实际开发中，对于mq的消息丢失问题，主要是两个步骤“发现”和“补偿” 处理</p><h3 id="发现" tabindex="-1"><a class="header-anchor" href="#发现"><span>发现</span></a></h3><p>在实际项目中通常会采用对账的方式去做，发现就是指我们要<strong>主动去发现</strong>消息丢失了所以通过对账，就是<strong>通过对比上下游的数据来看是否我们的消息有丢失</strong>。那么对于对账又分为两种，一种实时对账，一种离线对账</p><h4 id="实时对账" tabindex="-1"><a class="header-anchor" href="#实时对账"><span>实时对账</span></a></h4><p>实时对账可以通过定时任务去做</p><p>比如下面场景：</p><p>系统A，它在状态1的时候同步调用系统B的接口，而系统B会记录到B的表里面，记录A的状态为2，</p><figure><img src="'+i+'" alt="image-20250805234257838" tabindex="0" loading="lazy"><figcaption>image-20250805234257838</figcaption></figure><p>同时发一个消息给系统A，推动A表的状态由1变为2，这个时候如何知道B发出的消息是否丢失？。</p><figure><img src="'+n+'" alt="image-20250805234657754" tabindex="0" loading="lazy"><figcaption>image-20250805234657754</figcaption></figure><p>如下设计</p><p>可以这样设计当系统A在状态一同步调用系统B之前，可以创建一个两分钟之后执行的一个定时任务，</p><figure><img src="'+r+'" alt="image-20250805234759231" tabindex="0" loading="lazy"><figcaption>image-20250805234759231</figcaption></figure><p>正常情况下系统A在2分钟之后是能够从状态一变更为状态二的</p><p>那么这个定时任务的逻辑就是查询当前系统A的一个状态是否已经变更为二，如果没有就认为系统B发送给系统A的消息丢失了</p><figure><img src="'+o+'" alt="image-20250805234853856" tabindex="0" loading="lazy"><figcaption>image-20250805234853856</figcaption></figure><p>当然你这个创建定时任务的逻辑一定不能将异常抛出来，导致我们正常的一个业务逻辑的一个阻断，所以说我们的对账逻辑一定是一个弱依赖</p><p>这里是要注意的，那如果有一些场景下定时任务的创建时间点它不能由系统A决定的，那就可以去设置一个定时扫表任务了，比如说我隔一段时间去扫表进行对照，同时扫描系统A和系统B的表，捞出来那些两个系统不一致的数据，那么不一致的就是消息丢失了的</p><h4 id="离线对账" tabindex="-1"><a class="header-anchor" href="#离线对账"><span>离线对账</span></a></h4><p>如果你们会产出离线数据表的话，那么可以利用这个离线数据表进行对账,在每天产出数据之后，可以拉取系统A和系统B的离线表对，那么这个思路其实和实时对账的思路是一致的，但实时性肯定是没有实时对账好的</p><h3 id="补偿" tabindex="-1"><a class="header-anchor" href="#补偿"><span>补偿</span></a></h3><p>然后第二个步骤呢就是补偿</p><p>一定要开发一个接口，并且有条件的可以开发一个页面进行逻辑补偿，那它的内部逻辑就是可以主动的去推系统A的状态由一变更为二进行补偿那么这个接口的使用前提是你已经确定了这个消息是丢失了的才去这样的进行处理</p><p>总结：</p><p>消息丢失与重复消费的高频面试题处理方法，强调通过实时/离线对账发现异常，结合定时任务或扫表任务对比上下游数据，确保消息丢</p><p>失；并设计补偿接口主动修复状态，弱依赖业务流程避免阻断。总结发现与补偿两步策略，为大厂面试提供实用解决方案。</p><p>消息丢失检测与对账机制</p><p>1、消息丢失需通过发现与补偿机制，对账对比上下游数据</p><p>2、实时/离线对账结合定时任务，检测消息同步异常</p><p>3、定时任务监控状态变更，识别系统B消息发送失败</p><p>消息丢失补偿与离线对账方法</p><p>1、通过离线数据表对比系统A与B数据实现对账</p><p>2、开发接口与页面进行消息丢失补偿处理</p><p>3、小对账流程分发现异常与主动补偿两步骤</p><h2 id="二、消息重复问题" tabindex="-1"><a class="header-anchor" href="#二、消息重复问题"><span>二、消息重复问题</span></a></h2>',37)]))}]]),c=JSON.parse('{"path":"/Java%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%96%87/MQ%E7%AF%87/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%92%8C%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%92%8C%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98.html","title":"MQ消息丢失与消息重复问题","lang":"zh-CN","frontmatter":{"description":"MQ消息丢失与消息重复问题 一、MQ消息丢失问题 在实际开发中，对于mq的消息丢失问题，主要是两个步骤“发现”和“补偿” 处理 发现 在实际项目中通常会采用对账的方式去做，发现就是指我们要主动去发现消息丢失了所以通过对账，就是通过对比上下游的数据来看是否我们的消息有丢失。那么对于对账又分为两种，一种实时对账，一种离线对账 实时对账 实时对账可以通过定时...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/Java%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%96%87/MQ%E7%AF%87/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%92%8C%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%92%8C%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"DL的博客"}],["meta",{"property":"og:title","content":"MQ消息丢失与消息重复问题"}],["meta",{"property":"og:description","content":"MQ消息丢失与消息重复问题 一、MQ消息丢失问题 在实际开发中，对于mq的消息丢失问题，主要是两个步骤“发现”和“补偿” 处理 发现 在实际项目中通常会采用对账的方式去做，发现就是指我们要主动去发现消息丢失了所以通过对账，就是通过对比上下游的数据来看是否我们的消息有丢失。那么对于对账又分为两种，一种实时对账，一种离线对账 实时对账 实时对账可以通过定时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-05T20:27:26.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-05T20:27:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MQ消息丢失与消息重复问题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-05T20:27:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"git":{"createdTime":1754425646000,"updatedTime":1754425646000,"contributors":[{"name":"dai1314906","username":"dai1314906","email":"dailin359@gmail.com","commits":1,"url":"https://github.com/dai1314906"}]},"readingTime":{"minutes":3.46,"words":1039},"filePathRelative":"Java高频八股文/MQ篇/消息丢失和消息重复问题/消息丢失和消息重复问题.md","localizedDate":"2025年8月5日","excerpt":"\\n<h2>一、MQ消息丢失问题</h2>\\n<p>在实际开发中，对于mq的消息丢失问题，主要是两个步骤“发现”和“补偿” 处理</p>\\n<h3>发现</h3>\\n<p>在实际项目中通常会采用对账的方式去做，发现就是指我们要<strong>主动去发现</strong>消息丢失了所以通过对账，就是<strong>通过对比上下游的数据来看是否我们的消息有丢失</strong>。那么对于对账又分为两种，一种实时对账，一种离线对账</p>\\n<h4>实时对账</h4>\\n<p>实时对账可以通过定时任务去做</p>\\n<p>比如下面场景：</p>\\n<p>系统A，它在状态1的时候同步调用系统B的接口，而系统B会记录到B的表里面，记录A的状态为2，</p>","autoDesc":true}')},6262:(a,e)=>{e.A=(a,e)=>{const p=a.__vccOpts||a;for(const[a,t]of e)p[a]=t;return p}}}]);